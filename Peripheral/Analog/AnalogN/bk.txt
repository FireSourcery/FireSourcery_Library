static inline void AnalogN_CaptureResults_ISR(AnalogN_T * p_analogn, uint8_t analogId)
{
	Analog_T * p_analogI = &p_analogn->CONFIG.P_ANALOGS[analogId];
//	AnalogN_Conversion_T * p_activeConversion = p_analogI->p_ActiveConversion; /* casting void pointer */
//	Queue_PeekFront(&p_analogI->ConversionQueue, &p_activeConversion); //read an address

//	const Analog_ConversionAdc_T * p_adcConversion 	= &p_activeConversion->P_ADC_CONVERSIONS[analogId];
//	const Analog_ConversionVirtualMap_T * p_map 			= &p_activeConversion->MAP;
//	AnalogN_AdcFlags_T * p_signalComplete 			= p_activeConversion->P_SIGNAL_BUFFER;
////	Analog_Options_T options 		 		= p_map->P_VIRTUAL_CONVERSION->OPTIONS;
//	Analog_OnComplete_T onConversionComplete  		= p_map->P_VIRTUAL_CONVERSION->ON_COMPLETE;
//	void * p_onConversionCompleteContext 			= p_map->P_ON_COMPLETE_CONTEXT;

//	volatile static uint32_t debug = 0;

//	if((_Analog_GetIsActive(p_analogI) == true)) //debug only
//	{


	if (_Analog_CaptureResults(p_analogI) == true) //all channels complete
	{
		//Do not run if is capture local peak and not peak found
		if((((options.CaptureLocalPeak == true) && (p_analogI->IsLocalPeakFound == false)) == false))
		{
			p_signalComplete->AdcFlags &= ~(1UL << analogId); //debug only

			if (onConversionComplete != 0U)
			{
				// only run oncomplete if conversion has completed on all adcs
	//			p_signalComplete->AdcFlags &= ~(1UL << analogId);
				if (p_signalComplete->AdcFlags == 0U)
				{
					onConversionComplete(p_onConversionCompleteContext);
				}
			}
		}

		todo check repeat function
		if((options.ContinuousConversion == true) && (((options.CaptureLocalPeak == true) && (p_analogI->IsLocalPeakFound == true)) == false))
		{
#if !defined(CONFIG_ANALOG_ADC_HW_FIFO_ENABLE)
			if(p_activeConversion->MAP.P_VIRTUAL_CONVERSION->CHANNEL_COUNT > 1U)
			{
				_Analog_ActivateConversion(p_analogI, p_adcConversion, p_map);
			}
			else
			{
				p_analogI->ActiveAdcChannelIndex = 0U; //auto reactivate, still need to reset index
			}
#elif defined(CONFIG_ANALOG_SW_CONTINUOUS_CONVERSION)
			_Analog_ActivateConversion(p_analogI, p_adcConversion, p_map);
#endif
		}
		else //local peak found
		{

			if(_Analog_DequeueConversion(p_analogI) == true)
			{
				/* p_analogI->p_ActiveConversion updated */
				p_activeConversion = p_analogI->p_ActiveConversion;
				_Analog_ActivateConversion(p_analogI, &p_activeConversion->P_ADC_CONVERSIONS[analogId], &p_activeConversion->MAP);
			}
			else
			{
//			Analog_Dectivate(p_analogI);
			}
		}
	}
//
//	}
//	else
//	{
//		debug++;
//	}
}