static inline uint32_t Motor_LoadParameterAll(Motor_T * p_motor)
{
//	Flash_EEPROM_ReadBytes(&MotorFlashMain, &p_motor->Parameters, p_motor->p_Constants->P_EEPROM, sizeof(Motor_Parameters_T));

}

static inline uint32_t Motor_SaveParametersAll(Motor_T * p_motor)
{
 	Flash_EEPROM_WriteAlignedBytes(&MotorFlashMain, p_motor->p_Constants->P_EEPROM, &p_motor->Parameters, sizeof(Motor_Parameters_T));
}

///*******************************************************************************/
///*!
//    @brief  State
//*/
///*******************************************************************************/
//static void FocSpinEntry(Motor_T * p_motor)
//{
//	Motor_FOC_SetAngleControl(p_motor);
//}
//
//static void FocSpinProc(Motor_T * p_motor)
//{
//	Motor_FOC_ProcAngleControl(p_motor);
//	Motor_SixStep_ProcPhaseControl(p_motor);
//
////	only check flags in pwm loop. set flags in main loop
//	if(Motor_PollFaultFlag(p_motor))	{ StateMachine_Semisynchronous_ProcTransition(&p_motor->StateMachine, MOTOR_TRANSITION_FAULT);	}
//	if(Motor_GetSpeed(p_motor) == 0)	{ StateMachine_Semisynchronous_ProcTransition(&p_motor->StateMachine, MOTOR_TRANSITION_STOP);	}
//
//}
//const State_T * const P_FOC_SPIN_TRANSITION_STATE_MAP[MOTOR_STATE_MACHINE_TRANSITION_MAP_LENGTH] =
//{
//	[MOTOR_TRANSITION_FAULT] 					= &MOTOR_STATE_FAULT,
//	[MOTOR_TRANSITION_ALIGN_COMPLETE] 			= &MOTOR_STATE_FAULT,
//	[MOTOR_TRANSITION_STOP] 					= &MOTOR_STATE_STOP,
//};
//
 
//
//void (* const FOC_SPIN_OUTPUT_FUNCTION_MAP[MOTOR_STATE_MACHINE_INPUT_MAP_LENGTH])(Motor_T * p_motor) =
//{
//
//};
//
//const State_T MOTOR_STATE_FOC_SPIN =
//{
//	.PP_INPUT_TRANSITION_STATE_MAP 			= P_FOC_SPIN_TRANSITION_STATE_MAP,
//	.P_INPUT_TRANSITION_FUNCTION_MAP 		= (StateMachine_StateFunction_T *)FOC_SPIN_TRANSITION_FUNCTION_MAP,
//	.P_INPUT_OUTPUT_FUNCTION_MAP 	= (StateMachine_StateFunction_T *)FOC_SPIN_OUTPUT_FUNCTION_MAP,
//	.TRANSITION_ENTRY = (StateMachine_StateFunction_T)FocSpinEntry,
//	.OUTPUT = (StateMachine_StateFunction_T)FocSpinProc,
//};
//
//
//
///*******************************************************************************/
///*!
//    @brief  State
//*/
///*******************************************************************************/
//static void SixStepSpinEntry(Motor_T * p_motor)
//{
//	Motor_SixStep_SetPhaseControl(p_motor);
//}
//
//static void SixStepSpinProc(Motor_T * p_motor)
//{
//	Motor_SixStep_ProcPhaseControl(p_motor);
//
////	only check flags in pwm loop. set flags in main loop
////	if(Motor_PollFaultFlag(p_motor))	{ StateMachine_Semisynchronous_ProcTransition(&p_motor->StateMachine, MOTOR_TRANSITION_FAULT);	}
////	if(Motor_GetSpeed(p_motor) == 0)	{ StateMachine_Semisynchronous_ProcTransition(&p_motor->StateMachine, MOTOR_TRANSITION_STOP);	}
//}
//const State_T * const P_SIX_STEP_SPIN_TRANSITION_STATE_MAP[MOTOR_STATE_MACHINE_TRANSITION_MAP_LENGTH] =
//{
//	[MOTOR_TRANSITION_FAULT] 					= &MOTOR_STATE_FAULT,
//	[MOTOR_TRANSITION_ALIGN_COMPLETE] 			= &MOTOR_STATE_FAULT,
//	[MOTOR_TRANSITION_STOP] 					= &MOTOR_STATE_STOP,
//};
 
//void (* const SIX_STEP_SPIN_OUTPUT_FUNCTION_MAP[MOTOR_STATE_MACHINE_INPUT_MAP_LENGTH])(Motor_T * p_motor) =
//{
//	[MOTOR_TRANSITION_FAULT] 		= 0U,
//	[MOTOR_TRANSITION_INIT] 		= 0U,
//	[MOTOR_TRANSITION_STOP] 		= 0U,
//	[MOTOR_TRANSITION_CALIBRATE_ADC] 	= 0U,
//	[MOTOR_TRANSITION_ALIGN] 		= 0U,
//	[MOTOR_TRANSITION_SPIN] 			= 0U,
//};
//
//const State_T MOTOR_STATE_SIX_STEP_SPIN =
//{
//	.PP_INPUT_TRANSITION_STATE_MAP 			= P_SIX_STEP_SPIN_TRANSITION_STATE_MAP,
//	.P_INPUT_TRANSITION_FUNCTION_MAP 		= (StateMachine_StateFunction_T *)SIX_STEP_SPIN_TRANSITION_FUNCTION_MAP,
//	.P_INPUT_OUTPUT_FUNCTION_MAP 	= (StateMachine_StateFunction_T *)SIX_STEP_SPIN_OUTPUT_FUNCTION_MAP,
//	.TRANSITION_ENTRY = (StateMachine_StateFunction_T)SixStepSpinEntry,
//	.OUTPUT = (StateMachine_StateFunction_T)SixStepSpinProc,
//};




 