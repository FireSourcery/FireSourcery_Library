 
//typedef void (*ProtocolG_ReqFunction_T)(); //generic function pointer type
//typedef void * ProtocolG_ReqFunction_T;
//typedef uint32_t (*ProtocolG_ReqFunctionExecute_T)	(uint8_t * p_txPacket, uint8_t * p_txSize, volatile const uint8_t * p_rxPacket, void * p_execute, void * p_writeRegs, volatile const void * p_readRegs);
//typedef uint32_t (*ProtocolG_ReqFunctionRead_T)		(uint8_t * p_txPacket, uint8_t * p_txSize, volatile const uint8_t * p_rxPacket, volatile const void * p_readRegs);
//typedef uint32_t (*ProtocolG_ReqFunctionWrite_T)		(volatile const uint8_t * p_rxPacket, void * p_writeRegs);
//typedef uint32_t (*ProtocolG_ReqFunctionReadWrite_T)	(uint8_t * p_txPacket, uint8_t * p_txSize, volatile const uint8_t * p_rxPacket, void * p_writeRegs, volatile const void * p_readRegs);
//typedef uint32_t (*ProtocolG_ReqFunctionFull_T)		(uint8_t * p_txPacket, uint8_t * p_txSize, volatile const uint8_t * p_rxPacket, void * p_writeRegs, volatile const void * p_readRegs, Protocol_ControlContext_T * p_control);

//typedef uint32_t (*ProtocolG_ControlFunction_T)		(Protocol_ControlContext_T * p_control);
		
			//pre parse rx id
//	const uint8_t * const P_TX_ACK_PACKET;		const uint8_t TX_ACK_PACKET_LENGTH; //preparse cmd ack?
//	const (*const BUILD_TX_ACK_PACKET)(volatile uint8_t * p_txPacket, uint8_t * p_txSize);
//	const (*const BUILD_TX_NACK_DATA)(volatile uint8_t * p_txPacket, uint8_t * p_txSize);
//	const (*const BUILD_TX_NACK_CMD)(volatile uint8_t * p_txPacket, uint8_t * p_txSize);
//	const (*const BUILD_TX_NACK_TIMEOUT)(volatile uint8_t * p_txPacket, uint8_t * p_txSize);

//				//pre id, reception ack
				//DataLinkTxString(p_protocol, p_protocol->p_Specs->P_TX_ACK_PACKET_STRING, p_protocol->p_Specs->TX_ACK_PACKET_LENGTH);
						
//				if (p_protocol->p_Specs->BUILD_TX_NACK_CMD != 0U){p_protocol->p_Specs->BUILD_TX_NACK_CMD(p_protocol->CONFIG.P_TX_PACKET_BUFFER, &p_protocol->TxLength, cmd);}
//				if (p_protocol->p_Specs->BUILD_TX_NACK_DATA != 0U){p_protocol->p_Specs->BUILD_TX_NACK_DATA(p_protocol->CONFIG.P_TX_PACKET_BUFFER, &p_protocol->TxLength, cmd);}
//				if (p_protocol->p_Specs->P_TX_NACK_TIMEOUT != 0U){p_protocol->p_Specs->BUILD_TX_NACK_TIMEOUT(p_protocol->CONFIG.P_TX_PACKET_BUFFER, &p_protocol->TxLength, time);}

//				if (p_protocol->p_Specs->BUILD_TX_ACK_PACKET != 0U)	{p_protocol->p_Specs->BUILD_TX_ACK_PACKET(p_protocol->CONFIG.P_TX_PACKET_BUFFER, &p_protocol->TxLength);}
		



//typedef ProtocolG_ReqExt_T Protocol_ReqFlash_T;	

//run inside isr if nonblocking super loop speed is too slow
//Encoded and non encoded checks
//static bool ProtocolG_RxPacket_ISR(ProtocolG_T * p_protocol)
//{
////	uint8_t rxChar;
//	bool isComplete = false;
//
//	case SUBSTATE_1:
//		if (DataLinkRxByte(p_protocol, &p_protocol->CONFIG.P_RX_PACKET_BUFFER[p_protocol->RxIndex]) != false)
//		{
//			p_protocol->RxIndex++;
//			p_protocol->TimeStart = *(p_protocol->CONFIG.P_TIMER);  //reset  byte timeout
//		}
//
//	case SUBSTATE_2:
////		if (*p_protocol->CONFIG.P_TIMER - p_protocol->TimeStart < p_protocol->p_Specs->TIME_OUT_PACKET) //packet time out if needed
//
//
//			if(isComplete)
//			{
//				p_protocol->RxIndex = 0;
//				//reset packet timeout
//			}
//		}
//		else
//		{
////			set SUBSTATE_1
//			p_protocol->RxIndex = 0;
//			//send txtimeout
//		}
//
//	return isComplete;
//}



					
	////section pass to user function
	//	typedef const struct
	//	{
	//		volatile uint8_t * const P_RX_PACKET_BUFFER;
	//		volatile uint8_t * const P_TX_PACKET_BUFFER;
	//		volatile void * const P_WRITE_REGS;
	//		volatile const void * const P_READ_REGS;
	//	}
	//	ProtocolG_AppContext_T; //packet app interface
	//
	//	typedef protocolg_retcode_t (*ProtocolG_ReqOpContext_T) (ProtocolG_AppContext_T * p_appContext, void * p_processContext);
	//
	//	typedef const struct
	//	{
	//		const uint8_t * const P_TX_ACK_PACKET_STRING;
	//		const uint8_t TX_ACK_PACKET_LENGTH;

	//		volatile void * P_PROCESS_CONTEXT;

	//		const ProtocolG_ReqOpContext_T 	PRE_PROCESS; //parse rx
	//
	//	//	const ProtocolG_ReqProcess_T 	PROCESS;
	//		const protocolg_retcode_t WAIT_PROCESS_CODE; //nonblocking wait state
	//		const uint8_t WAIT_PROCESS_TIME_OUT;
	//
	//		const ProtocolG_ReqOpContext_T 	POST_PROCESS; //buildtx,
	//	} ProtocolG_ReqExtOp_T; //format	
 

//typedef struct
//{
//		uint8_t VarWritten;
//} Protocol_FlashContext_T;

//typedef Flash_T Protocol_FlashContext_T;
//
//typedef uint32_t (*ProtocolG_ReqFlashParseRx_T)				(volatile const uint8_t * p_rxPacket, volatile void * p_writeRegs, Protocol_FlashContext_T * p_flashContext);
//typedef protocolg_retcode_t (*ProtocolG_ReqFlashProcess_T)	(Protocol_FlashContext_T * p_processContext);
//typedef uint32_t (*ProtocolG_ReqFlashBuildTx_T)				(uint8_t * p_txPacket, size_t * p_txSize, volatile const void * p_readRegs, Protocol_FlashContext_T * p_flashContext);

//typedef const struct Protocol_ReqFlash_Tag
//{
//	bool REPEAT;
//	bool WAIT_FOR_PROCESS;
//	uint8_t * P_WAIT_FOR_ACK_STRING;
//	const ProtocolG_ReqFlashParseRx_T 	PARSE_RX;
//	const ProtocolG_ReqFlashBuildTx_T 	BUILD_TX;
//	const ProtocolG_ReqOnComplete_T 	ON_COMPLETE;
//	bool Start;
//} Protocol_ReqFlash_T;


//		case PROTOCOL_STATE_DATAGRAM_CONTROL: //only needed if datagram is on signal and rx non unique ack
//			while (DataLinkRxByte(p_protocol, &p_protocol->CONFIG.P_RX_PACKET_BUFFER[p_protocol->RxIndex]) == true)
//			{
//				p_protocol->RxIndex++;
//
//				if(p_protocol->RxIndex == p_protocol->p_ReqActive->P_EXT_SYNC->WAIT_RX_ACK_LENGTH)
//				{
//					if(strncmp(p_protocol->CONFIG.P_RX_PACKET_BUFFER, p_protocol->p_ReqActive->P_EXT_SYNC->P_WAIT_RX_ACK_STRING, p_protocol->p_ReqActive->P_EXT_SYNC->WAIT_RX_ACK_LENGTH) == 0)
//					{
//									if(Datagram_GetDataRemainingCount(&p_protocol->Datagram) == 0U)
//									{
//										if(closing response)
//										{
//											Datagram_Disable(&p_protocol->Datagram);
//											if(p_protocol->p_ReqActive->P_EXT_PROCESS->BUILD_TX_PROCESS != 0U)
//											{
//												p_protocol->p_ReqActive->P_EXT_PROCESS->BUILD_TX_PROCESS(p_protocol->CONFIG.P_TX_PACKET_BUFFER, &p_protocol->TxLength, p_protocol->CONFIG.P_READ_REGS, p_protocol->p_ReqActive->P_EXT_CONTEXT);
//												DataLinkTxString(p_protocol, p_protocol->CONFIG.P_TX_PACKET_BUFFER, p_protocol->TxLength);
//											}
//										}
//										else
//										{
//											p_protocol->State = PROTOCOL_STATE_WAIT_RX_BYTE_1;
//										}
//									}
//									else
//									{
//										Datagram_Signal(&p_protocol->Datagram);
//										p_protocol->RxIndex = 0U;
//									}
//					}
//					break;
//				}
//				else if(p_protocol->RxIndex == p_protocol->p_ReqActive->P_EXT_SYNC->WAIT_RX_NACK_LENGTH)
//				{
//					if(strncmp(p_protocol->CONFIG.P_RX_PACKET_BUFFER, p_protocol->p_ReqActive->P_EXT_SYNC->P_WAIT_RX_NACK_STRING, p_protocol->p_ReqActive->P_EXT_SYNC->WAIT_RX_NACK_LENGTH) == 0)
//					{
//						if (p_protocol->NackCount < p_protocol->p_ReqActive->P_EXT_SYNC->RX_NACK_REPEAT)
//						{
//							p_protocol->NackCount++;
//							DataLinkTxString(p_protocol, p_protocol->CONFIG.P_TX_PACKET_BUFFER, p_protocol->TxLength); //retransmit
//						}
//						else
//						{
//							p_protocol->NackCount = 0U;
//							p_protocol->State = PROTOCOL_STATE_WAIT_RX_BYTE_1;
//						}
//					}
//					break;
//				}
//				else if(p_protocol->RxIndex >= p_protocol->p_Specs->RX_LENGTH_MAX)
//				{
//					p_protocol->State = PROTOCOL_STATE_WAIT_RX_BYTE_1;
//					break;
//				}
//			}
//			break;


//typedef const struct
//{
//	const uint8_t * const P_TX_ACK_RECEPTION_STRING;
//	const uint8_t TX_ACK_RECEPTION_LENGTH;
//
//	volatile void * P_PROCESS_CONTEXT;
//
//	const ProtocolG_ReqParseRx_T PARSE_RX;
//	const ProtocolG_ReqReadApp_T READ_APP;			//split to allow reuse
//
//	const ProtocolG_ReqProcess_T WAIT_PROCESS;
//	const protocolg_retcode_t WAIT_PROCESS_CODE; //exit nonblocking wait state upon reception
//	//repeat process code
//	const uint8_t WAIT_PROCESS_TIME_OUT;
//
//	const ProtocolG_ReqWriteApp_T WRITE_APP;
//	const ProtocolG_ReqBuildTx_T BUILD_TX;
//
//	//	bool (*const WAIT_RX_ACK) (const void * p_rxPacket, uint8_t rxCount);
//	const uint8_t * const P_WAIT_RX_ACK_STRING; //fp faster over string compare?
//	const uint8_t * const P_WAIT_RX_NACK_STRING;
//	const uint8_t WAIT_RX_ACK_LENGTH;
//	const uint8_t WAIT_RX_NACK_LENGTH;
//	const uint8_t WAIT_RX_ACK_TIME_OUT;
//
////	const ProtocolG_ReqProcess_T RX_ACK_PROCESS;
//	const ProtocolG_ReqProcess_T RX_NACK_PROCESS;
//
////	const ProtocolG_ReqBuildTx_T RX_ACK_BUILD_TX;
//	const ProtocolG_ReqBuildTx_T RX_NACK_BUILD_TX;
//
//	const uint8_t RX_NACK_REPEAT_MAX; //stay in wait for ack state
//
//	const ProtocolG_ReqBuildTx_T RX_ACK_ERROR_BUILD_TX;
//	const ProtocolG_ReqBuildTx_T RX_ACK_TIME_OUT_BUILD_TX;
//	//	const uint8_t * const P_TX_NACK_WAIT_STRING;  //when wait for ack times out
//	//	const uint8_t TX_NACK_WAIT_LENGTH;
//} ProtocolG_ReqExt_T;
