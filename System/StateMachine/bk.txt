//#ifdef CONFIG_STATE_MACHINE_INPUT_ENUM_USER_DEFINED
//
//#elif defined (CONFIG_STATE_MACHINE_INPUT_UINT8)
///*
// * Default configuration
// */
//#else
//	#define CONFIG_STATE_MACHINE_INPUT_UINT8
//#endif


/*
 * Compile time defined array vs pointer
 *	if assuming only 1 state machine, compile time memory allocation is more convenient
 *	pointer allows varying sizes for multiple state machines
 */
//#if  (defined (CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_ARRAY) && defined (STATE_TRANSITION_INPUT_COUNT) && defined (STATE_SELF_TRANSITION_INPUT_COUNT))
///*
// * User provide
// * #define STATE_TRANSITION_INPUT_COUNT
// * #define STATE_SELF_TRANSITION_INPUT_COUNT
// */
//#elif defined (CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_ARRAY)
//
//	#ifndef STATE_TRANSITION_INPUT_COUNT
//		#error "USER MUST DEFINE STATE_TRANSITION_INPUT_COUNT"
//	#endif
//
//	#ifndef STATE_SELF_TRANSITION_INPUT_COUNT
//		#error "USER MUST DEFINE STATE_SELF_TRANSITION_INPUT_COUNT"
//	#endif
//
//#elif defined (CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_EXTERNAL)
///*
// * Default configuration
// */
//#else
//	#define CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_EXTERNAL
//#endif



//#ifdef CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_EXTERNAL
//	#define STATE_MACHINE_TRANSITION_INPUT_COUNT (p_stateMachine->TransitionInputCount)
//	#define STATE_MACHINE_TOTAL_INPUT_COUNT (p_stateMachine->TotalInputCount)
//#elif defined(CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_ARRAY)
//	#define STATE_MACHINE_TOTAL_INPUT_COUNT (STATE_MACHINE_TRANSITION_INPUT_COUNT + STATE_MACHINE_SELF_TRANSITION_INPUT_COUNT)
//#endif

	//#ifdef CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_STATIC //module memory allocation, all state machine must be same size
	//	const struct State_Tag * const p_TransitionStateMap[STATE_MACHINE_SELF_TRANSITION_INPUT_COUNT];
	//	void (* const p_TransitionFunctionMap[STATE_MACHINE_TRANSITION_INPUT_COUNT ])(void * userData);
	//#elif defined(CONFIG_STATE_MACHINE_MAPS_MEMORY_ALLOCATION_EXTERNAL)
 
  * List Implementation
 *	using list and check condition will have no wasted space
 *	must check all entries and end of list. user provide function to validate transition
 
 //	struct StateTransition
//	{
	const struct State_Tag (*const (*const PP_INPUT_TRANSITION_STATE_MAP));
	void (*(*const P_INPUT_TRANSITION_FUNCTION_MAP))(volatile void * p_typeData);
//	};

	void (*(*const P_INPUT_OUTPUT_FUNCTION_MAP))(volatile void * p_typeData);

//	void (* const Exit)(void);

	void (*const TRANSITION_ENTRY)(volatile void * p_typeData); 	/* common to all transition to current state */
	void (*const OUTPUT)(volatile void * p_typeData); 				/* Synchronous output / Common output to all inputs for asynchronous case */
 
void StateMachine_Init
(
	StateMachine_T * p_stateMachine,
	const State_T * p_stateInitial,
	uint8_t transitionInputCount,
	uint8_t selfTransitionInputCount,
	const void * p_userData
)
{
	p_stateMachine->p_StateInitial 				= p_stateInitial;
	p_stateMachine->p_StateActive 				= p_stateInitial;
	p_stateMachine->InputTransitionMapLength 	= transitionInputCount;
	p_stateMachine->InputOutputMapLength 		= selfTransitionInputCount;
	p_stateMachine->p_TypeData 					= p_userData;

#ifdef CONFIG_STATE_MACHINE_MULTITHREADED_LIBRARY_DEFINED
	p_stateMachine->Mutex = 1U;
#endif
}


//static inline void State_InputAccumulated(StateMachine_t * stateMachine, StateInput_t input)
//{
//	for (uint8_t bitIdx = 0; bitIdx < STATE_INPUT_OUTPUT_COUNT; bitIdx++)
//	{
//		if (((input >> bitIdx) & (uint32_t)0x01) && stateMachine->p_StateActive->InputOutputMap[bitIdx] =! 0) stateMachine->p_StateActive->InputOutputMap[bitIdx]();
//	}
//}
//void State_SetInputAccumulated(StateMachine_t * stateMachine, uint8_t input)
//{
//	stateMachine->InputOutput |= ((uint32_t)0x01 << input);
//}




